package aaafcKeyManage.DESDemo;

import java.security.spec.InvalidParameterSpecException;

import aaafcKeyManage.Exception.AssessmentTimeOverflowException;
import aaafcKeyManage.Exception.DecryptProcessFailedException;
import aaafcKeyManage.Exception.EncryptProcessFailedException;
import aaafcKeyManage.Exception.GenerateKeyFailedException;
import aaafcKeyManage.main.MyAlgorithmParameterSpec;
import aaafcKeyManage.main.MyMessage;
import aaafcKeyManage.main.MyProcessUtil;

/**
 * 
 * @author aaafc
 *
 */
public class MyDESAssessment {

	private MyDESProcessor processor;

	public MyDESAssessment() {
		processor = new MyDESProcessor();
	}

	public synchronized long[] generateProcess(int keyLoops) throws Exception {

		long[] result = new long[keyLoops];

		try {
			for (int i = 0; i < keyLoops; i++) {
				result[i] = processor.keyManager.generateKey();
				processor.keyManager.removeKey();
			}
		} catch (Exception e) {
			throw e;
		}

		return result;
	}

	/**
	 * Calculate the time for encrypting and decrypting by DES algorithm. Messages
	 * are generated randomly with the same length. Keys are identical. Careful: the
	 * method is synchronized by the object.
	 * 
	 * @param messageLength
	 *            The random length of the messages.
	 * @param processLoops
	 *            The time of loops of the process.
	 * @return An array, calculates the list of the processes.
	 * @throws Exception
	 *             Whatever the first exception occurs.
	 */
	public synchronized long[][] encryptAndDecryptProcess(int messageLength, int processLoops) throws Exception {
		long[][] result = new long[2][processLoops];
		MyMessage tempMessage;

		try {
			for (int i = 0; i < processLoops; i++) {
				tempMessage = new MyMessage(new String(MyProcessUtil.randomBytes(messageLength)));
				result[0][i] = processor.EncryptMessage(tempMessage);
				result[1][i] = processor.DecryptMessage(tempMessage);
			}
			return result;
		} catch (Exception e) {
			throw e;
		}
	}

	/**
	 * Calculate the time for encrypting and decrypting and find their average
	 * 
	 * @param messageLength
	 * @param processLoops
	 * @return An array, where array[0] is the average time for Encrypting
	 * and array[1] is the average time for Decrypting
	 * @throws Exception
	 */
	public long[] averageEncryptAndDecryptProcess(int messageLength, int processLoops) throws Exception {
		long[][] result = encryptAndDecryptProcess(messageLength, processLoops);
		long[] avg = new long[] { 0, 0 };
		long length = result[0].length;
		for (int i = 0; i < length; i++) {
			avg[0] += result[0][i] / length;
			avg[1] += result[1][i] / length;
		}

		return avg;
	}
	
	/**
	 * Calculates time cost for encrypting and decrypting messages by RSA algorithm.
	 * Key pairs are generated by parameterSpec object. Careful: the method is synchronized by the
	 * object
	 * @param messages
	 * 			String array which contains the messages to be delivered.
	 * @param nSpec
	 * 			parameter array which contains the parameter for each message. 
	 * @param processLoops
	 * 			integer array which contains how many loops for each message.
	 * @return	An long[2][length] array, where 2 indicates encrypting time and decrypting time respectively,
	 * 	length indicates how many messages are encrypted/decrypted.
	 * @throws EncryptProcessFailedException
	 * @throws DecryptProcessFailedException
	 * @throws GenerateKeyFailedException
	 * @throws AssessmentTimeOverflowException
	 * 			Indicates the assessment process takes too many time(in the case, 200000 milliseconds) for calculating
	 * @throws InvalidParameterSpecException
	 */
	public synchronized long[][] encryptAndDecryptProcess(String[] messages, MyAlgorithmParameterSpec[] nSpec,
			int processLoops[])
			throws EncryptProcessFailedException, DecryptProcessFailedException, GenerateKeyFailedException, 
			AssessmentTimeOverflowException, InvalidParameterSpecException{
		long generalSt = System.currentTimeMillis();
		MyMessage tempMessage = null;
		long[][] result = new long[2][messages.length];
		for (int i = 0; i < messages.length; i++) {
			for(int j = 0; j < processLoops[i]; j++)
			{
				processor.keyManager.generateKey(nSpec[i]);
				tempMessage = new MyMessage(messages[i]);
				result[0][i] += processor.EncryptMessage(tempMessage, processor.keyManager.keyList.size() - 1, nSpec[i]) / processLoops[i];
				result[1][i] += processor.DecryptMessage(tempMessage) / processLoops[i];
				processor.keyManager.removeKey();
				if(System.currentTimeMillis() - generalSt > 200000)
				{
					throw new AssessmentTimeOverflowException();
				}
			}
		}
		return result;
		
	}
}
