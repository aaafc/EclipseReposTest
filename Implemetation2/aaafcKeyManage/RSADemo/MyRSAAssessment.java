package aaafcKeyManage.RSADemo;

import aaafcKeyManage.Exception.EncryptProcessFailedException;
import aaafcKeyManage.Exception.GenerateKeyFailedException;

import java.security.spec.InvalidParameterSpecException;

import aaafcKeyManage.Exception.AssessmentTimeOverflowException;
import aaafcKeyManage.Exception.DecryptProcessFailedException;
import aaafcKeyManage.main.MyAlgorithmParameterSpec;
import aaafcKeyManage.main.MyMessage;
import aaafcKeyManage.main.MyProcessUtil;

/**
 * This is a class for generate an assessment object for RSA algorithm.
 * @author aaafc
 *
 */
public class MyRSAAssessment {

	// public static void main(String args[]) {
	//
	// MyRSAAssessment mrsaa = new MyRSAAssessment();
	// try {
	// long[][] temp = mrsaa.encryptAndDecryptProcess(117, 1023, 200);
	// long en = 0;
	// long de = 0;
	// for(int i = 0; i < temp[0].length; i++)
	// {
	// en += temp[0][i];
	// de += temp[1][i];
	// }
	// en /= temp[0].length;
	// de /= temp[0].length;
	// System.out.println("Encrypt: " + en + " || Decrypt: " + de);
	// } catch (Exception e) {
	// // TODO Auto-generated catch block
	// e.printStackTrace();
	// }
	// }

	private MyRSAProcessor processor = null;

	public MyRSAAssessment() {
		processor = new MyRSAProcessor();
	}

	public synchronized long[] generateProcess(int[] keySizes) throws GenerateKeyFailedException{
		long[] result = new long[keySizes.length];
		try {
			for (int i = 0; i < keySizes.length; i++) {
				result[i] = processor.keyManager.generateKey(keySizes[i]);
				processor.keyManager.removeKey();
			}
			return result;
		} catch (GenerateKeyFailedException e) {
			
			// TODO Auto-generated catch block
			throw e;
		}

	}

	public synchronized long[] generateProcess(int keySize, int keyLoops) throws GenerateKeyFailedException {
		if (keyLoops > 10000) {
			System.out.println("Too much loops of key generation!");
			keyLoops = 10000;
		}
		if (keySize > 2048) {
			System.out.println("Invalid key size: Key size should be smaller than 2048 and bigger than 966");
			keySize = 2048;
		}
		long[] result = new long[keyLoops];
		for (int i = 0; i < keyLoops; i++) {
			result[i] = processor.keyManager.generateKey(keySize);
			processor.keyManager.removeKey();
		}
		return result;

	}

	/**
	 * Calculates time cost for encrypting and decrypting messages by RSA algorithm.
	 * Messages are created randomly with the fixed length for each loop. Key pairs
	 * are identical for each loop. Careful: the method is synchronized by the
	 * object
	 * 
	 * @param messageLength
	 *            the length for random plain message.
	 * @param keySize
	 *            the generating size for random key pair.
	 * @param processLoops
	 *            number of loops for encrypting and decrypting message.
	 * @return an long array, where array[0] is the average time for encrypting,
	 *         array[1] is average time for decrypting.
	 * @throws Exception
	 */
	public synchronized long[][] encryptAndDecryptProcess(int messageLength, int keySize, int processLoops)
			throws Exception {
		if (keySize > 2048 || processLoops > 1000 || messageLength < 10 || messageLength > 100000 || keySize < 966
				|| processLoops < 1) {
			System.out.println("Too much calculating steps in RSA en and de.\n");
			throw new Exception();
		}
		MyMessage tempMessage = null;
		long[][] result = new long[2][processLoops];
		processor.keyManager.generateKey(keySize);
		try {
			for (int i = 0; i < processLoops; i++) {
				tempMessage = new MyMessage(new String(MyProcessUtil.randomBytes(messageLength)));
				result[0][i] = processor.EncryptMessage(tempMessage);
				result[1][i] = processor.DecryptMessage(tempMessage);
			}
		} catch (Exception e) {
			throw e;
		}

		return result;
	}

	/**
	 * Calculate the average time for encrypting and decrypting processes by RSA
	 * algorithm.
	 * 
	 * @param messageLength
	 * 
	 * @param keySize
	 * 
	 * @param processLoops
	 * 
	 * @return An array, where array[0] is the average time for Encrypting and
	 *         array[1] is the average time for Decrypting
	 * @throws Exception
	 */
	public long[] averageEncryptAndDecryptProcess(int messageLength, int keySize, int processLoops) throws Exception {
		long[][] result = encryptAndDecryptProcess(messageLength, keySize, processLoops);
		long[] avg = new long[] { 0, 0 };
		long length = result[0].length;
		for (int i = 0; i < length; i++) {
			avg[0] += result[0][i] / length;
			avg[1] += result[1][i] / length;
		}

		return avg;
	}
	
	/**
	 * Calculates time cost for encrypting and decrypting messages by RSA algorithm.
	 * Key pairs are generated by parameterSpec object. Careful: the method is synchronized by the
	 * object
	 * @param messages
	 * 			String array which contains the messages to be delivered.
	 * @param nSpec
	 * 			parameter array which contains the parameter for each message. 
	 * @param processLoops
	 * 			integer array which contains how many loops for each message.
	 * @return	An long[2][length] array, where 2 indicates encrypting time and decrypting time respectively,
	 * 	length indicates how many messages are encrypted/decrypted.
	 * @throws EncryptProcessFailedException
	 * @throws DecryptProcessFailedException
	 * @throws GenerateKeyFailedException
	 * @throws AssessmentTimeOverflowException
	 * 			Indicates the assessment process takes too many time(in the case, 500000 milliseconds) for calculating
	 * @throws InvalidParameterSpecException
	 */
	public synchronized long[][] encryptAndDecryptProcess(String[] messages, MyAlgorithmParameterSpec[] nSpec,
			int processLoops[])
			throws EncryptProcessFailedException, DecryptProcessFailedException, GenerateKeyFailedException, 
			AssessmentTimeOverflowException, InvalidParameterSpecException{
		long generalSt = System.currentTimeMillis();
		MyMessage tempMessage = null;
		long[][] result = new long[2][messages.length];
		for (int i = 0; i < messages.length; i++) {
			for(int j = 0; j < processLoops[i]; j++)
			{
				processor.keyManager.generateKey(nSpec[i]);
				tempMessage = new MyMessage(messages[i]);
				result[0][i] += processor.EncryptMessage(tempMessage, processor.keyManager.publicKeys.size() - 1, nSpec[i]) / processLoops[i];
				result[1][i] += processor.DecryptMessage(tempMessage) / processLoops[i];
				processor.keyManager.removeKey();
				if(System.currentTimeMillis() - generalSt > 500000)
				{
					throw new AssessmentTimeOverflowException();
				}
			}
		}
		return result;
		
	}

}
